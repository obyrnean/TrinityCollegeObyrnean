#include "WiFiS3.h" // needed for wifi 
#include "HUSKYLENS.h"
#include <SoftwareSerial.h>

HUSKYLENS huskylens;
SoftwareSerial mySerial(3, 9); // RX, TX
//HUSKYLENS green line >> Pin 3; blue line >> Pin 9
void printResult(HUSKYLENSResult result);

//motor declarations
const int M1 = 6;                  // Left motor control pin 1 forward
const int M2 = 7;                  // Left motor control pin 2
const int M3 = 8;                  // Right motor control pin 1 forward
const int M4 = 12;                  // Right motor control pin 2
const int ENABLE_LEFT_PIN = 11;    // Enable pin for left motor
const int ENABLE_RIGHT_PIN = 10;   // Enable pin for right motor
//sensors
const int LEYE = A3;               // Left sensor pin
const int REYE = A4;               // Right sensor pin

//wifi declarations
WiFiServer server(80); // created a wifi server on port 80, this number will be needed for processing to connect to it.
WiFiClient client; // simply creating a cient

bool isGoPressed = false;// this boolean will be used to check if the button has been pressed to go, allowing us to either execute line following etc, or stop 

// ultrasonics declarations
const int US_TRIG = 4; // trigger for US sensor will send out a pulse
const int US_ECHO = 2; // this pin will listen for the pulse
int loopCount = 0; // loopcount is used to distinguish how many times void loop is ran 
int distance; // distance of ultrasonics 
int objectDistance = 0; // object distance for control loop
long duration; // time for pulse to return
String stringDistance; // stores distance as string for communication wirelessly to processing with readstring function

//Wheel encoders to measure RPM and distance
// left and right encoders input pins 
const int Left_Encoder = A2;
const int Right_Encoder = A1;
volatile int Encoder_Count_Left = 0; // volatile alerts the compiler this will change by the isr 
volatile int Encoder_Count_Right = 0;
// total distance travelled by the buggy
double Distance_Travelled = 0;
String D_travelled; // used to communicate wirelessly the double value
double previousDistance = 0; // needed to measure dx the change in distance each loop
// wheel diameter measured at 63.5mm 
double circumference = 2*PI*(0.0635/2); // circumference in m 
//speeds of each wheel initialised 
int leftspeed = 220;
int rightspeed = 220;

//method 1 PID button counter, allow us to use the same button for on and off 
int speedControl1_Counter = 0;
int speedControl2_Counter = 0;
// the speed recieved by processing which we must match 
int speedControl1_RefSpeed;
// buttons initialised as unpressed
bool speedControl1_pressed = false;
//bool speedControl2_pressed = false;
// current and previous time for the dt
unsigned long currentMillis = 0;
unsigned long previousMillis = 0;
// the current speed the buggy is travelling at
double currentSpeed = 0;

// Define PID constants for control speed 1
// the target distance for object following
int speedcontrol2_distance = 15;
// here the PID was callibrated using Ziegler nichols
// where steady oscillation occured at k = 0.75 and the time period of oscillation = 0.1825s average
// these coefficients are left as they are so we can remember the intial ziegler nichols values and clearly can see how the method is implemented
double Kp = 0.75*0.6; // Proportional gain
double Ki = 0.5*0.1825; // Integral gain
double Kd = 0.125*0.1825; // Derivative gain
double previousError = 0; // keeps track of the error from the last iteration
double integral = 0;
double avgSpeed = 0; // average speed over the last few loops, this is to avoid errors
// time and position changes
double dt; // change in time each loop
double dx; // change in distance each loop 
double previous_refSpeed = 0; // used to monitor the previous ref speed as changed by the GUI
double previous_Distance = 0;
//average speed over last 20 loops decs
unsigned long prevTime = 0;
double prevDistance = 0;

//gold challenge tag booleans for turning
bool turn_left = false;
bool turn_right = false;


void setup() {
  //husky lens setup
  Serial.begin(115200);
    mySerial.begin(9600);
    while (!huskylens.begin(mySerial))
    {
        Serial.println(F("Begin failed!"));
        Serial.println(F("1.Please recheck the \"Protocol Type\" in HUSKYLENS (General Settings>>Protocol Type>>Serial 9600)"));
        Serial.println(F("2.Please recheck the connection."));
        delay(100);
    }

// declaring pins as inputs or outputs accordingly

  pinMode(LEYE, INPUT);
  pinMode(REYE, INPUT);
  pinMode(M1, OUTPUT);
  pinMode(M2, OUTPUT);
  pinMode(M3, OUTPUT);
  pinMode(M4, OUTPUT);
  pinMode(ENABLE_LEFT_PIN, OUTPUT);
  pinMode(ENABLE_RIGHT_PIN, OUTPUT);
  pinMode(US_TRIG, OUTPUT);
  pinMode(US_ECHO, INPUT);
  pinMode(Left_Encoder, INPUT);
  pinMode(Right_Encoder, INPUT_PULLUP);
  //encoder ISR to detect a change
  attachInterrupt(digitalPinToInterrupt(Left_Encoder), LeftEncoderISR, CHANGE); // engages our Function when there is a change from high to low
  attachInterrupt(digitalPinToInterrupt(Right_Encoder), RightEncoderISR, CHANGE);
  //wifi

  char ssid[] = "iPhone (4)"; // this is in the header file, if using hotspot or lab wifi just replace these with strings within ""
  char pass[] = "12345678";
  WiFi.begin(ssid, pass); // attempt to make a connection with these credentials

  while (WiFi.status() != WL_CONNECTED) { //allows us to check if connection is not established, will be stuck in this loop
    delay(500);
    Serial.print(".");
  }
  // if we made it here, a connection has been made
  Serial.println();
  Serial.print("Connected to WiFi. IP address: "); // print IP to serial port, this will change depending on the netowrk and must be copied into our processing code
  Serial.println(WiFi.localIP());
  server.begin(); // begin the server 
}
void LeftEncoderISR() { // ISR for left encoder
  Encoder_Count_Left++; // will increase 8 times per revolution
}

void RightEncoderISR() { // ISR for left encoder
  Encoder_Count_Right++;
}
// we should measure both wheels and find the average to account for differences on turning radius

void startMotors() { // function just alerts us that go has been pressed on processing
  Serial.println("Go button pressed");
  isGoPressed = true; // updating the boolean to control the main if block in our code below
}

void stopMotors() { // stops motor
  Serial.println("Stop button pressed"); // alerts that button is pressed
  isGoPressed = false; // updated boolean
  // Stop motors set all logic and enable pins low to ensure no movement.
  digitalWrite(M1, LOW);
  digitalWrite(M2, LOW);
  digitalWrite(M3, LOW);
  digitalWrite(M4, LOW);
  analogWrite(ENABLE_LEFT_PIN, 0);
  analogWrite(ENABLE_RIGHT_PIN, 0);
  // initiate speed control PID
      speedControl1_pressed = false;
      // set the speed
  // using the boolean means the buggy will wait until go is pressed no matter how many loops we itterate over
}
//toggle on and off speed control mode with each press, we use the control boolean to execute the according code
void speedControl1() {
  Serial.println("Speed control method 1 pressed");
  //Serial.println("control 1 bool is ");
  //Serial.println(speedControl1_pressed);
  //this saves us having two buttons
   //speedControl1_Counter++;
   if (speedControl1_Counter % 2 == 0){
     speedControl1_pressed = false;
     // reset speeds to default when current mode is disabled
     leftspeed = 200;
     rightspeed = 200;
   }
   else {
  speedControl1_pressed = true;
   }
}

/*void speedControl2() {
  Serial.println("Speed control method 2 pressed");
  //Serial.println("control 2 bool is ");
  //Serial.println(speedControl2_pressed);
  //this saves us having two buttons
   speedControl2_Counter++;
   if (speedControl2_Counter % 2 == 0){
     speedControl2_pressed = false;
     // reset speeds to default 
     leftspeed = 200;
     rightspeed = 200;
   }
   else {
  speedControl2_pressed = true;
   } 
}*/



void loop() {
  //declare currents we want to check each loop
  currentMillis = millis(); // current time
  // update distance_travelled
  Distance_Travelled = ((Encoder_Count_Left+Encoder_Count_Right)/16.0)*circumference; // averaging the two wheels accounts for errors during turning due to different radius
 
 
  //handle the camera object detection

 if (!huskylens.request()) Serial.println(F("Fail to request data from HUSKYLENS, recheck the connection!"));
    else if(!huskylens.isLearned()) Serial.println(F("Nothing learned, press learn button on HUSKYLENS to learn one!"));
    else if(!huskylens.available()) Serial.println(F("No block or arrow appears on the screen!"));
    else
    {
        Serial.println(F("###########"));
        while (huskylens.available())
        {
            HUSKYLENSResult result = huskylens.read();
            printResult(result);
        }    
    }

    /////////////////////////////////////////////
  // Handle client connection
  if (!client || !client.connected()) { // alerts us when a client is connected 
    client = server.available();
    if (client) {
      Serial.println("Client connected");
    }
  }

  if (client && client.connected()) { 
    CheckWifiComm(); // checks for and reads incoming characters or strings from the client
  } else { // alerts us if client is not conenected otherwise 
    Serial.println("Client disconnected");
    if (client) {
      client.stop();
    }
    
  }
  // if go is pressed, proceed with line following and object detection code
  if (isGoPressed) {
    // debug 
    /*Serial.print(leftspeed);
    Serial.println(rightspeed);*/
    // debug button
    /*Serial.print("Is Control Button 2 Pressed: ");
  Serial.println(speedControl2_pressed);
  Serial.print("Is Control Button 1 Pressed: ");
  Serial.println(speedControl1_pressed);*/

    //ultrasonic test for object presence after experimenting every 3 loops was sufficent for speed control and stopping before crashing into an object
    if (loopCount % 10 == 0) { // here we can control using loopCount how often to check for objects
      checkUltrasonics();
    }
    

    //line following logic
    // remember Remember when programming the IR sensors they are Active Low Output: "Active Low" means that the sensor's output signal goes low (or near 0V) when it detects an obstacle. 
 
    int leftSensor = digitalRead(LEYE); // reads each sensor
    int rightSensor = digitalRead(REYE);

      if (leftSensor == HIGH && rightSensor == HIGH) {
      moveForward(leftspeed, rightspeed);
    } else if (leftSensor == LOW && rightSensor == HIGH) {
      turnLeft(leftspeed*0.4, rightspeed*1.6);
    } else if (leftSensor == HIGH && rightSensor == LOW) {
      turnRight(leftspeed * 1.6, rightspeed*0.4);
    } else {
      // reached a junction make the advised turn
      if(!turn_left && !turn_right){

        digitalWrite(M1, LOW);
        digitalWrite(M2, LOW);
        digitalWrite(M3, LOW);
        digitalWrite(M4, LOW);

      }
      else {
      Junction_turning(); // move forward cautiously or stop, change these values depending on what we want to do 
      }
    }
    
    
    // Comunicates the total distance travelled by the buggy to the console of the processing window
    //if (loopCount % 350 == 0) {
      //D_travelled = String(Distance_Travelled);
      //client.write("distance travelled is ");
      //client.write(D_travelled.c_str());
      //client.write(" m.\n");
    //}
    
    
  dx = (Distance_Travelled-previousDistance)*100; //cm
  dt = (currentMillis - previousMillis)*0.001; // s
  currentSpeed = dx/dt; // current speed



  //cehck if control speed 1 is pressed and call the PID
  if(speedControl1_pressed) {
    controlSpeed1();
  }

  }

//averaging speed avoids zeros and doubles
// this could also be done by only measuring dx and dt every x loops, however the code is done this way so we can accurately print and see the response each loop
// for more accurate pid calibration
if (loopCount % 20 == 0) {
  avgSpeedfunc();
}
//

//print txt for matlab graphing and calibration this format can be easily read by our matlab script
/*Serial.print(millis()); // Print the timestamp
Serial.print(", "); // Separate values with a comma
Serial.print(distance); // Print current speed
Serial.print(", "); // Separate values with a comma
Serial.println(speedcontrol2_distance); */// Print reference speed and end the line

//previous updates of time and distance 
previousMillis = currentMillis;
previousDistance = Distance_Travelled;

    loopCount++;
//delay(1000); // Adjust delay as needed for sensor response
}



//moving functions
// Function to move forward at reduced speed
void moveForward(int left_Speed, int right_Speed) {
  //speeds cannot exceed 255 for analoguewrite
  if (left_Speed>255) {
    left_Speed = 255;
  }
  if (right_Speed>255) {
    right_Speed = 255;
  }
  digitalWrite(M1, HIGH);
  digitalWrite(M2, LOW);
  digitalWrite(M3, HIGH);
  digitalWrite(M4, LOW);
  analogWrite(ENABLE_LEFT_PIN, left_Speed);  // Adjust speed here
  analogWrite(ENABLE_RIGHT_PIN, right_Speed); // Adjust speed here
  
}

// Function to turn left at slower speed
void turnLeft(int left_Speed, int right_Speed) {
   if (left_Speed>=225) { // at higher speeds the the 60% increase and 60% decrease does not steer well as max speed is constrained
    left_Speed = 105;
    rightspeed = 240;
  }
  

  digitalWrite(M1, HIGH);
  digitalWrite(M2, LOW);
  digitalWrite(M3, HIGH);
  digitalWrite(M4, LOW);
  analogWrite(ENABLE_LEFT_PIN, left_Speed);   // Adjust speed here
  analogWrite(ENABLE_RIGHT_PIN, right_Speed); // Adjust speed here
}

// Function to turn right at slower speed
void turnRight(int left_Speed, int right_Speed) {
   if (left_Speed>=225) { // we need to constrain steering 
    rightspeed = 105;
    leftspeed = 240;
  }
  

  digitalWrite(M1, HIGH);
  digitalWrite(M2, LOW);
  digitalWrite(M3, HIGH);
  digitalWrite(M4, LOW);
  analogWrite(ENABLE_LEFT_PIN, left_Speed);   // Adjust speed here
  analogWrite(ENABLE_RIGHT_PIN, right_Speed); // Adjust speed here
}

void checkUltrasonics() {
  
  digitalWrite(US_TRIG, LOW);
      delayMicroseconds(2);
      //Send high signal from trigger pin
      digitalWrite(US_TRIG, HIGH);
      delayMicroseconds(10);
      digitalWrite(US_TRIG, LOW);
      //MEASURES HOW LONG THE SIGNAL TAKES TO RETURN. 
      duration = pulseIn(US_ECHO, HIGH); // gets the duration of the pulse in microseconds
      distance = duration / 60; // calculates the distance, Sound travels at 343 meters per second, which means it needs 29.155 microseconds per centimeter, the object must travel twice the distance to return.


      //stop motors if an object is detected at this set distance
      if (distance <= 5) {
        // Stop all motors
        digitalWrite(M1, LOW);
        digitalWrite(M2, LOW);
        digitalWrite(M3, LOW);
        digitalWrite(M4, LOW);
        analogWrite(ENABLE_LEFT_PIN, 0);
        analogWrite(ENABLE_RIGHT_PIN, 0);

        Serial.println("Object detected within 15 cm! Stopping motors."); // this is just for debug

        //send the data to processing to wirelessly display in the serial monitor
       /*stringDistance = String(distance);// converts to a string
         client.write("Object detected ");
         // we need to convert the data to a string and a c style string so that it can be sent by client.write and read by .readstring() (tested without this it didnt work)
         client.write(stringDistance.c_str());
         client.write(" cm away\n");*/

        // Wait until object is moved before continuing the loop
        while (distance <= 15) {
          //check constantly for distance until it is greater than the minimum 
          digitalWrite(US_TRIG, LOW);
          delayMicroseconds(2);
          digitalWrite(US_TRIG, HIGH);
          delayMicroseconds(10);
          digitalWrite(US_TRIG, LOW);

          duration = pulseIn(US_ECHO, HIGH);
          distance = duration / 60;

        }
        //Serial.println("Object moved! Resuming motors.");
      }
}

//check wifi communication
void CheckWifiComm() {
  // ensures client is itialized, not null and is connected
    while (client.available()) { // while data is available
    //unlike bronze we change this to a string incase we get double digit numbers from the slider
      char c = client.read(); // read in the data
      //int value = c.toInt(); // Convert the received string to an integer if possible 
      //Serial.println(value);

      // check if it is an integer and update ref speed 
      /*if ((value != 0 || c == "0")) {
        // Process the received integer value
        speedControl1_RefSpeed = value;
        Serial.println("Reference speed updated");
        Serial.println(speedControl1_RefSpeed);

      } */

      // check if is go or stop or speed controls and call appropriate functions
      
      if (c == 'g') { 
        startMotors();
      } else if (c == 's') {
        stopMotors();
      }
     
    }
}
// this was needed to overcome the errors caused, travelling at 20cm/s per second, some loops would print 0 cm/s and the following loop prints 40 cm/s
void avgSpeedfunc() {
  // simply gets speed the same way as in our loop but is only called every x loops
    unsigned long currTime = millis();
    double currDistance = Distance_Travelled; // Assuming Distance is declared and updated elsewhere
    double distDiff = (currDistance - prevDistance)*100;
    unsigned long timeDiff = (currTime - prevTime);
    if (timeDiff != 0) { // Avoid division by zero
        avgSpeed = ((distDiff) / (timeDiff))*(1/0.001);
    }
    // Update previous values for next iteration
    prevTime = currTime;
    prevDistance = currDistance;
}

//control mode 1 PID
void controlSpeed1() {

  double error = speedControl1_RefSpeed - currentSpeed; // Calculate error

  // Compute PID terms
  double proportional = Kp * error;
  integral += error*dt;
  double derivative = (error - previousError)/dt;

  double output = proportional + Ki * integral + Kd * derivative;

  //just for the first time after new speed is selected 
  // after testing this creates a smoother response and reduces over shoot when the speed is changed from a small value to large value instantly from the GUI
  // loop only runs once when the value is changed from the gui
   if (speedControl1_RefSpeed != previous_refSpeed){
     double start_speed = 
    output = (speedControl1_RefSpeed- previous_refSpeed)/2;
  }

  // Apply control output to adjust motor speeds
  // For simplicity, assume left and right speeds are adjusted simultaneously
  leftspeed += output;
  rightspeed += output;

  // Ensure motor speeds are within valid range
  leftspeed = constrain(leftspeed, 0, 255);
  rightspeed = constrain(rightspeed, 0, 255);

  // Update previous error for derivative term calculation
  previousError = error;

  //coms for control loop 1 updates to GUI
  // depending on the wifi quality how often the values are communicated can have a great effect on the smooothnes of both the buggy and processing
  /*if (speedControl1_pressed && loopCount % 200 == 0) {
      
      client.write("current speed is ");
      client.write(String(avgSpeed).c_str());

    }*/
 previous_refSpeed = speedControl1_RefSpeed;

  //print txt for matlab graphing and calibration of Ziegler nichols method
/*Serial.print(millis()); // Print the timestamp
Serial.print(", "); // Separate values with a comma
Serial.print(avgSpeed); // Print current speed
Serial.print(", "); // Separate values with a comma
Serial.println(speedControl1_RefSpeed); // Print reference speed and end the line*/

}

//camera results 
void printResult(HUSKYLENSResult result) {
  if (result.command == COMMAND_RETURN_BLOCK) {
    //Serial.println(String()+F("Block:xCenter=")+result.xCenter+F(",yCenter=")+result.yCenter+F(",width=")+result.width+F(",height=")+result.height+F(",ID=")+result.ID);

    // Check if the ID is 1
    // do what we need to do with id 1, Speed limit low
    //change speed control to true set ref speed to a low speed

    if (result.ID == 1) {
      Serial.println("Detected ID is 1! updatig speed to 13 cm/s");
      // Your additional actions or code here if the ID is 1
      // initiate speed control PID
      // we can turn off speed control in our stop function
      speedControl1_pressed = true;
      // set the speed
      speedControl1_RefSpeed = 12;
      client.write("2");
      
    }
    
    // Check if the ID is 2
    // do what we need to do with id 2 
    // high speed limit, chang ref speed to high and let control speed 1 = true
    if (result.ID == 2) {
      Serial.println("Detected ID is 2! changing speed to 22 cm/s ");
      // initiate speed control PID
      speedControl1_pressed = true;
      // set the speed
      speedControl1_RefSpeed = 20;
      client.write("3");
      // Your additional actions or code here if the ID is 2
    }

    // Check if the ID is 3
    // do what we need to do with id 3
    // turn right ahead true 
    //turn left ahead false
    if (result.ID == 3) {
      Serial.println("Detected ID is 3! turn left ahead");
      // Your additional actions or code here if the ID is 3
      turn_left = true;
      turn_right = false;
      client.write("4");
    }

    // Check if the ID is 4
    // do what we need to do with id 4
    // turn left ahead true
    // turn right ahead false
    if (result.ID == 4) {
      Serial.println("Detected ID is 4! turn right ahead");
      // Your additional actions or code here if the ID is 4
      turn_right = true;
      turn_left = false; 
      client.write("5");
    }
  } else if (result.command == COMMAND_RETURN_ARROW) {
    //Serial.println(String()+F("Arrow:xOrigin=")+result.xOrigin+F(",yOrigin=")+result.yOrigin+F(",xTarget=")+result.xTarget+F(",yTarget=")+result.yTarget+F(",ID=")+result.ID);
  } else {
    //Serial.println("Object unknown!");
  }
}


void Junction_turning() {
  //TURN SHARPLY TO REMAIN ON TRACK NORMAL LINE FOLLOWING SHOULD CORRECT THE PATH AFTER A BIG ADJUSTMENT IS MADE 
if(turn_right) {
//ID
  //change direction 
  digitalWrite(M1, LOW);
  digitalWrite(M2, HIGH);
  // right wheel reverse
  digitalWrite(M3, HIGH);
  digitalWrite(M4, LOW);
  //djust speeds
  analogWrite(ENABLE_LEFT_PIN, 255);   // Adjust speed here
  analogWrite(ENABLE_RIGHT_PIN, 140); // Adjust speed here
  

}

if(turn_left) {

  //change direction of left motor
  digitalWrite(M1, HIGH);
  digitalWrite(M2, LOW);
  // right wheel reverse
  digitalWrite(M3, LOW);
  digitalWrite(M4, HIGH);
  //djust speeds
  analogWrite(ENABLE_LEFT_PIN, 255);   // Adjust speed here
  analogWrite(ENABLE_RIGHT_PIN, 255); // Adjust speed here
  

}

}
