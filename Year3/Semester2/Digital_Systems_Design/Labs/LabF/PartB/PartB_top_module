`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: Trinity College Dublin
// Engineer: Ane O'byrne
// 
// Create Date: 11.03.2025 17:06:56
// Design Name: LabF PartB Top Module
// Module Name: PartB_top_module
// Project Name: Top Module
// Target Devices: Basys-3
// Description: Top module connecting all files
// Revision 0.01 - File Created

//////////////////////////////////////////////////////////////////////////////////


module PartB_top_module(
    input wire clk,                  // Clock input
    input wire reset,                // Reset input
    input wire [4:0] button_input,   // 5-bit vector for push button inputs
    output wire [3:0] anode_sel,     // 4-bit anode selection for 7-segment display
    output wire [6:0] led_out        // 7-bit LED output for 7-segment display
);

    wire [4:0] buttons_output;      // Debounced push buttons output
    wire [7:0] Q;                   // 8-bit wire vector for temperature value
    reg [7:0] Q_next, Q_reg;        // Register for holding current and next state of Q

    // Instantiate the debouncer module (get cleaner button press version)
    debouncer db0 (
        .clk(clk),                  // Pass clock signal
        .reset(reset),              // Pass reset signal
        .button_in(button_input),   // Pass button input
        .button_out(buttons_output) // Output debounced button signals
    );

    // Instantiate 8 D flip-flops (DFF0 to DFF7)
    d_ff_reset DFF0 (
        .clk(clk),          // Connect clock to DFF0
        .reset(reset),      // Connect reset to DFF0
        .d(Q_next[0]),      // Connect Q_next[0] to D input of DFF0
        .q(Q[0])            // Store bit 0 of the temperature value in Q[0]
    );

    d_ff_reset DFF1 (
        .clk(clk),          // Connect clock to DFF1
        .reset(reset),      // Connect reset to DFF1
        .d(Q_next[1]),      // Connect Q_next[1] to D input of DFF1
        .q(Q[1])            // Store bit 1 of the temperature value in Q[1]
    );

    d_ff_reset DFF2 (
        .clk(clk),          // Connect clock to DFF2
        .reset(reset),      // Connect reset to DFF2
        .d(Q_next[2]),      // Connect Q_next[2] to D input of DFF2
        .q(Q[2])            // Store bit 2 of the temperature value in Q[2]
    );

    d_ff_reset DFF3 (
        .clk(clk),          // Connect clock to DFF3
        .reset(reset),      // Connect reset to DFF3
        .d(Q_next[3]),      // Connect Q_next[3] to D input of DFF3
        .q(Q[3])            // Store bit 3 of the temperature value in Q[3]
    );

    d_ff_reset DFF4 (
        .clk(clk),          // Connect clock to DFF4
        .reset(reset),      // Connect reset to DFF4
        .d(Q_next[4]),      // Connect Q_next[4] to D input of DFF4
        .q(Q[4])            // Store bit 4 of the temperature value in Q[4]
    );

    d_ff_reset DFF5 (
        .clk(clk),          // Connect clock to DFF5
        .reset(reset),      // Connect reset to DFF5
        .d(Q_next[5]),      // Connect Q_next[5] to D input of DFF5
        .q(Q[5])            // Store bit 5 of the temperature value in Q[5]
    );

    d_ff_reset DFF6 (
        .clk(clk),          // Connect clock to DFF6
        .reset(reset),      // Connect reset to DFF6
        .d(Q_next[6]),      // Connect Q_next[6] to D input of DFF6
        .q(Q[6])            // Store bit 6 of the temperature value in Q[6]
    );

    d_ff_reset DFF7 (
        .clk(clk),          // Connect clock to DFF7
        .reset(reset),      // Connect reset to DFF7
        .d(Q_next[7]),      // Connect Q_next[7] to D input of DFF7
        .q(Q[7])            // Store bit 7 of the temperature value in Q[7]
    );

    // Combinatorial block to compute Q_next (next state of Q)
    always @(*) begin
        if (buttons_output[4]) begin // If CENTRE is pressed, set Q_next to 22
            Q_next = 22; // Decimal value 22, which is 8'b00010110
        end
        else if (buttons_output[0] | buttons_output[3]) begin // If UP or RIGHT is pressed, increment Q
            Q_next = Q + 1;
        end
        else if (buttons_output[1] | buttons_output[2]) begin // If DOWN or LEFT is pressed, decrement Q
            Q_next = Q - 1;
        end
        else begin
            // No button pressed, retain the current Q value
            Q_next = Q;
        end
    end

    // Hold the current Q value and update on the rising edge of clk
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            Q_reg <= 8'b0;  // Reset Q to 0 on reset
        end else begin
            Q_reg <= Q_next;  // Update Q with the next state
        end
    end

    // Assign the value of Q_reg to the output Q
    assign Q = Q_reg;

    // Instantiate the seven-segment controller module
    seven_segment_controller seg (
        .clk(clk),              // Pass clock to the controller
        .reset(reset),          // Pass reset signal to the controller
        .temp(Q),               // Pass the 8-bit temperature value (Q) to the controller
        .anode_select(anode_sel),  // Connect anode selection to the top-level anode_sel
        .LED_out(led_out)        // Connect LED output to the top-level led_out
    );

endmodule
