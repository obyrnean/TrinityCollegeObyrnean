`timescale 1ns / 1ps

module DFF_module(
    input wire clk,                 // Clock input
    input wire reset,               // Reset input
    input wire [4:0] button_input,  // 5-bit vector for push button inputs
    output wire [3:0] anode_sel,    // 4-bit anode selection for 7-segment display
    output wire [6:0] led_out       // 7-bit LED output for 7-segment display
);

    // Wires for connecting internal signals
    wire [4:0] debounced_buttons;  // Debounced push buttons output
    wire [7:0] Q, Q_next;          // 8-bit wire vector for temperature value
    reg [7:0] Q_reg;               // Register for holding current state of Q

    // Instantiate the debouncer module
    debouncer db0 (
        .clk(clk), 
        .reset(reset), 
        .button_in(button_input), 
        .button_out(debounced_buttons)
    );

    // Instantiate 8 D flip-flops (DFF0 to DFF7)
    d_ff_reset DFF0 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[0]), // Connect Q_next[0] to D input of DFF0
        .q(Q[0])       // Store bit 0 of the temperature value in Q[0]
    );

    d_ff_reset DFF1 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[1]), // Connect Q_next[1] to D input of DFF1
        .q(Q[1])       // Store bit 1 of the temperature value in Q[1]
    );

    d_ff_reset DFF2 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[2]), // Connect Q_next[2] to D input of DFF2
        .q(Q[2])       // Store bit 2 of the temperature value in Q[2]
    );

    d_ff_reset DFF3 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[3]), // Connect Q_next[3] to D input of DFF3
        .q(Q[3])       // Store bit 3 of the temperature value in Q[3]
    );

    d_ff_reset DFF4 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[4]), // Connect Q_next[4] to D input of DFF4
        .q(Q[4])       // Store bit 4 of the temperature value in Q[4]
    );

    d_ff_reset DFF5 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[5]), // Connect Q_next[5] to D input of DFF5
        .q(Q[5])       // Store bit 5 of the temperature value in Q[5]
    );

    d_ff_reset DFF6 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[6]), // Connect Q_next[6] to D input of DFF6
        .q(Q[6])       // Store bit 6 of the temperature value in Q[6]
    );

    d_ff_reset DFF7 (
        .clk(clk),
        .reset(reset),
        .d(Q_next[7]), // Connect Q_next[7] to D input of DFF7
        .q(Q[7])       // Store bit 7 of the temperature value in Q[7]
    );

    // Combinatorial block to compute Q_next (next state of Q)
    always @(*) begin
        if (debounced_buttons[4]) begin
            // If CENTRE is pressed, set Q_next to 22
            Q_next = 22; // Decimal value 22, which is 8'b00010110
        end
        else if (debounced_buttons[0] | debounced_buttons[3]) begin
            // If UP or RIGHT is pressed, increment Q
            Q_next = Q + 1;
        end
        else if (debounced_buttons[1] | debounced_buttons[2]) begin
            // If DOWN or LEFT is pressed, decrement Q
            Q_next = Q - 1;
        end
        else begin
            // No button pressed, retain the current Q value
            Q_next = Q;
        end
    end

    // Register to hold the current Q value and update on the rising edge of clk
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            Q_reg <= 8'b0;  // Reset Q to 0 on reset
        end else begin
            Q_reg <= Q_next;  // Update Q with the next state
        end
    end

    // Assign the value of Q_reg to the output Q
    assign Q = Q_reg;

    // Instantiate the 7-segment display controller
    seven_segment_controller seg (
        .clk(clk),
        .reset(reset),
        .temp(Q),           // Pass the 8-bit temperature value to the seven-segment controller
        .anode_select(anode_sel),  // 7-segment anode selection
        .LED_out(led_out)        // 7-segment LED output
    );

endmodule

